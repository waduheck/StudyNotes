lc-3 与mips支持的数据类型
![[Pasted image 20231210132713.png]]
LC-3与mips中的寻址模式
![[Pasted image 20231210133252.png]]

在LC-3中，有三种基本的操作指令：

1. **NOT**：这是一个一元操作（unary operation），它只需要一个源操作数（source operand）。执行这个指令将对该操作数进行按位取反操作。

2. **ADD** 和 **AND**：这些是二元操作（binary operations），意味着它们需要两个源操作数。`ADD`执行的是二进制补码加法，而`AND`执行的是两个操作数的按位与操作。

另一方面，在MIPS体系结构中，有更多种类的操作指令：

1. **R型指令**：这些也是二元操作，但MIPS提供了更多这样的指令，包括`add`（加法）、`and`（与）、`nor`（或非）、`xor`（异或）等。

2. **I型指令**：这些是带有立即数操作数的R型操作指令的版本。立即数是在指令中直接给出的数值，这意味着I型指令中的某些操作数是直接编码在指令中的。

3. **F型操作**：表示浮点操作，即对浮点数进行的操作。

总的来说，这段话比较了LC-3和MIPS两种不同体系结构下的操作指令。LC-3具有较为简单的操作指令集，而MIPS具有更丰富的指令集，包括用于复杂算术和逻辑操作的指令，以及用于处理立即数和浮点数的指令。
![[Pasted image 20231210135427.png]]
![[Pasted image 20231210135417.png]]
![[Pasted image 20231210140148.png]]
## 寻址模式
在LC-3计算机体系结构中，`LD`（Load）和`LDI`（Load Indirect）指令都是用来从内存中加载数据到寄存器的，但它们的工作方式有所不同。

### LD（Load）指令：
![[Pasted image 20231210140357.png]]
- **直接寻址**：`LD`指令使用直接寻址方式。它将内存地址计算为当前PC（程序计数器）的值加上一个符号扩展的偏移量。
- **单步访问内存**：`LD`指令直接访问计算出的内存地址，并将该地址中的数据加载到指定的寄存器中。
- **操作**：如果指令是`LD R1, LABEL`，则会执行以下操作：
  1. 计算`LABEL`的地址（假设是PC的当前值加上偏移量）。
  2. 从该地址读取数据。
  3. 将读取的数据存储到`R1`寄存器中。

### LDI（Load Indirect）指令：
![[Pasted image 20231210141246.png]]
- **间接寻址**：`LDI`指令使用间接寻址方式。它同样将内存地址计算为当前PC的值加上一个符号扩展的偏移量，但这个计算出的地址并不是数据的存储位置，而是存储目标数据地址的位置。
- **两步访问内存**：`LDI`指令首先访问计算出的内存地址以获取数据的实际地址，然后再访问这个实际地址来获取数据。
- **操作**：如果指令是`LDI R1, LABEL`，则会执行以下操作：
  1. 计算`LABEL`的地址（假设是PC的当前值加上偏移量）。
  2. 从该地址读取另一个地址。
  3. 然后从第二个读取的地址中读取数据。
  4. 将读取的数据存储到`R1`寄存器中。

简而言之，`LD`指令执行单次内存访问来加载数据，而`LDI`执行两次内存访问来加载数据：第一次获取数据的真实地址，第二次才是获取数据本身。这种间接寻址机制在处理数组、指针和数据结构时特别有用。

### LDR
![[Pasted image 20231210144003.png]]
![[Pasted image 20231210144255.png]]
在LC-3计算机体系结构中，`LDR`（Load Register）指令用于基址寻址方式的内存访问。这种指令允许从内存中加载数据到寄存器，其地址由基址寄存器加上一个偏移量来确定。

#### LDR指令的格式

一个典型的`LDR`指令可能看起来像这样：

```
LDR DR, BaseR, offset
```

其中：
- `DR` 是目的寄存器，即将接收内存数据的寄存器。
- `BaseR` 是基址寄存器，其内容用作访问内存时的起始地址。
- `offset` 是一个6位的有符号数，它将被加到`BaseR`的内容上以得到最终的内存地址。

#### LDR指令的作用

`LDR`指令的主要作用是提供了一种灵活的内存访问方式。与直接寻址（如`LD`指令）相比，基址寻址允许更为动态的内存管理，因为它依赖于寄存器的值加上一个偏移量来计算地址。这种方法的一些用途包括：

- **数组和结构体的访问**：可以通过改变偏移量来访问数组的不同元素或结构体的不同字段。
- **栈操作**：在使用栈结构时，`BaseR`通常是指向栈顶的指针（如堆栈指针寄存器），而偏移量用于访问栈顶以下的元素。
- **模块化编程**：函数或过程可以使用`LDR`指令来访问局部变量，其中`BaseR`是指向当前活动记录的帧指针。

#### 使用LDR指令的优势

- **数据结构导航**：基址寻址使得在复杂数据结构中导航变得简单，只需改变偏移量即可。
- **编程灵活性**：它为编程提供了更多灵活性，因为可以在运行时动态计算内存地址。
- **代码简洁**：在处理结构化数据时，可以减少指令数量和复杂性。

总之，`LDR`指令是LC-3指令集中用于内存访问的强大工具之一，通过基址加偏移量的方式，它为内存访问提供了额外的灵活性和便捷性。

### LEA
![[Pasted image 20231210151935.png]]
在LC-3体系结构中，`LEA`（Load Effective Address）指令用于加载有效地址到寄存器中，而不是加载地址指向的内存位置的数据。`LEA`指令通常用于准备索引地址，例如数组或跳转表的地址，以便将来的内存访问或分支操作。

#### LEA指令的格式

`LEA`指令的基本格式如下：

```
LEA DR, label
```

这里：
- `DR` 是目的寄存器，它将存储计算出来的有效地址。
- `label` 是程序中某个位置的标签，其地址在编译时确定。

#### LEA指令的作用

`LEA`指令的主要作用是计算并加载一个内存地址而不是内存地址中的内容。这个指令的使用场景包括但不限于：

- **指针和引用**：当你需要一个对象的引用而不是对象本身时，`LEA`可以用来获取该对象的内存地址。
- **数组处理**：在处理数组时，`LEA`可以用来计算元素的地址，然后通过其他指令对这些地址进行操作。
- **准备跳转**：在实现跳转表或函数指针时，`LEA`可以加载指向具体代码位置的指针。
- **地址运算**：`LEA`可以用来进行复杂的地址运算，因为它可以将PC相对地址计算与数据的加载分离。

`LEA`指令的优点是它允许编程者在不实际访问内存数据的情况下操作地址。这使得在需要地址本身进行计算或者作为后续操作参数时，程序逻辑更加清晰和高效。

### LUI与ORI
在MIPS（Microprocessor without Interlocked Pipeline Stages）架构中，`LUI`（Load Upper Immediate）和`ORI`（OR Immediate）是两条用于处理立即数和寄存器内容的指令，它们都属于I型（立即数类型）指令。这两条指令在数据处理和地址计算中扮演着重要的角色。

#### LUI指令

`LUI`指令用于将一个16位的立即数加载到寄存器的高16位，同时将低16位清零。这是设置寄存器高16位值的直接方法。

##### 格式：

```
LUI $rd, immediate
```

这里，`$rd`是目的寄存器，`immediate`是一个16位的立即数。

##### 用途：

- **设置大数值**：当你想要在寄存器中设置一个大于16位的数值时，你可以使用`LUI`来设置高位，然后使用其他指令（如`ORI`）来设置低位。
- **地址加载**：在加载一个32位地址到寄存器时，`LUI`可以用来加载地址的高16位。

#### ORI指令

`ORI`指令用于执行立即数与寄存器内容的按位逻辑或（OR）操作，并将结果存储回寄存器。

##### 格式：

```
ORI $rd, $rs, immediate
```

这里，`$rd`是目的寄存器，`$rs`是源寄存器，`immediate`是一个16位的立即数。

##### 用途：

- **设置寄存器低位**：通常与`LUI`配合使用，设置寄存器中的低16位值。
- **逻辑运算**：进行逻辑或运算，可以用于设置、清除或测试特定的位。
- **小数值加载**：当立即数较小时，`ORI`可以直接将数值加载到寄存器的低位，而不影响高位。

#### 结合使用LUI和ORI

在MIPS中，这两条指令常常连续使用，以构造完整的32位立即数并加载到寄存器。例如，如果要将32位数值`0x12345678`加载到寄存器`$t0`，可以这样做：

```assembly
LUI $t0, 0x1234    ; 将0x1234加载到$t0的高16位，低16位设置为0
ORI $t0, $t0, 0x5678; 将0x5678或到$t0的低16位
```

执行这两个指令后，寄存器`$t0`将包含完整的32位数值`0x12345678`。

总结来说，`LUI`和`ORI`在MIPS指令集中用于操作立即数和寄存器内容，它们使得设置和修改32位寄存器中的数值变得可能和高效。

## 控制分支
![[Pasted image 20231210153227.png]]