## 寻址
好的，我会用通俗的语言来解释什么是字寻址（Word Addressable）和字节寻址（Byte Addressable），并举例说明。

### 字节寻址（Byte Addressable）

想象一下，内存就像是一排排的小盒子，每个盒子都有一个编号（这就是我们说的“地址”）。在字节寻址的系统中，每个盒子里只能放一个字节的数据（一个字节等于8位，可以是一个字符，比如'a'，或者是0到255之间的一个数字）。

#### 例子：
假设我们有一串字符 "hello"，在字节寻址的系统中，我们可以这样存储它们：

- 'h' 存在地址0的盒子里，
- 'e' 存在地址1的盒子里，
- 'l' 存在地址2的盒子里，
- 另一个 'l' 存在地址3的盒子里，
- 'o' 存在地址4的盒子里。

每个字符占据一个单独的地址。

### 字寻址（Word Addressable）

现在，假设每个盒子变大了，可以放更多的数据。在字寻址的系统中，每个盒子可以放一个“字”的数据。这里的“字”是一个固定的大小，比如16位、32位或者64位。所以，如果一个“字”是32位，那么每个盒子就可以存储4个字节（因为32位等于4个字节）。

#### 例子：
我们再拿 "hello" 这个例子。假设每个“字”是32位，那么在字寻址的系统中，我们可能这样存储：

- 'h', 'e', 'l', 'l' 这四个字符一起存储在地址0的盒子里（因为它们加起来是32位），
- 'o' 存储在地址1的盒子里（注意这里盒子里还有空间，但是因为是按“字”寻址，所以地址1的盒子是从这里开始的）。

在这种情况下，每个地址可以存储更多的信息，但是你不能只取出或只改变一个盒子里的一小部分，你需要一次处理整个“字”。

### 总结

- **字节寻址**：就像一排排只能放一个字节的小盒子，每个盒子有自己的编号，你可以单独访问每个盒子里的内容。
- **字寻址**：想象一排排可以放一个“字”（多个字节）的大盒子，每个盒子也有自己的编号，但你一次要处理一个盒子里的所有内容。

字节寻址提供了更高的灵活性，因为你可以精确地访问和修改内存中的每一个字节。字寻址在处理大量数据时可能更高效，但它牺牲了一些灵活性，因为你需要一次处理一个“字”的数据。

## 对齐

## 内存访问

### 读
![[Pasted image 20231207185028.png]]
### 写

## 大端小端模式

大端模式（Big-Endian）和小端模式（Little-Endian）是指计算机存储多字节数据（如整数、浮点数）时，字节序（即字节的排列顺序）的两种不同方式。这是计算机架构中的一个基本概念，对于数据的解释和处理有重要影响。

### 大端模式（Big-Endian）

在大端模式中，多字节数据的最高有效字节（MSB，即那个数值最大的字节）存储在最低的内存地址上，而最低有效字节（LSB，即那个数值最小的字节）存储在最高的内存地址上。可以将其类比为人类阅读数字的方式，即最重要的数字（最高位）放在前面。

#### 举例：

假设有一个16位的数 `0x1234`（在十六进制表示中），在大端模式下，它在内存中的存储方式如下：

```
内存地址    数据
0x00        0x12
0x01        0x34
```

### 小端模式（Little-Endian）

在小端模式中，多字节数据的最低有效字节（LSB）存储在最低的内存地址上，而最高有效字节（MSB）存储在最高的内存地址上。这可以视作一种“倒序”存储，其中最小的部分在前面。

#### 举例：

对于同一个数 `0x1234`，在小端模式下，它在内存中的存储方式如下：

```
内存地址    数据
0x00        0x34
0x01        0x12
```

### 重要性和应用

- **网络通信**：在网络协议中通常使用大端模式，因为它更符合人类阅读和理解数字的习惯。
- **不同平台的兼容性**：不同的计算机架构可能采用不同的字节序。例如，Intel x86架构是小端模式，而许多RISC架构（如IBM的PowerPC）是大端模式。
- **数据交换**：在不同字节序的系统间交换数据时，需要进行字节序转换，以保证数据的正确解释。

了解和处理字节序问题在跨平台软件开发、网络通信等领域非常重要，尤其是在处理二进制数据时。


## RAM

### DRAM

### SRAM

## DRAM控制器的调度算法——FR-FCFS
FR-FCFS（First-Ready First-Come First-Serve）是一种常用于DRAM控制器的调度算法，用于优化内存访问并减少由于缓存冲突导致的延迟。当发生访问不同行但同一bank的情况时，如您所描述的先访问第一行第一列，然后访问第二行第一列，会产生额外的延迟，因为每次访问不同行时，DRAM都需要进行预充电（precharge）和激活（activate）操作。FR-FCFS算法通过优化内存请求的处理顺序来解决这一问题。

### FR-FCFS算法的工作原理

#### 优先级调度
- **首先处理就绪请求**：FR-FCFS首先处理已经就绪的内存请求，即那些不需要额外行激活的请求。这通常意味着对当前已经在行缓存中的数据进行读写操作。
- **次之处理先到达的请求**：一旦所有就绪请求都被处理，算法再按照先到先服务的原则处理其他请求。

#### 减少行切换
- 通过优先处理那些可以直接服务的请求（即行缓存命中），FR-FCFS减少了行之间切换的次数，从而降低了因为行切换导致的延迟。

### 实现步骤

1. **请求分类**：将内存请求分为两类——行缓存命中（就绪）和行缓存未命中（非就绪）。
2. **优先处理行缓存命中**：检查行缓存命中的请求并优先处理。
3. **按先来先服务处理其他请求**：处理完所有行缓存命中的请求后，按照到达顺序处理剩余请求。

### 效果

- **降低延迟**：FR-FCFS通过减少行激活和预充电操作的次数，降低了内存访问的平均延迟。
- **提高吞吐量**：更高效的内存请求处理提高了DRAM的整体吞吐量。

### 应用

- **适用于多种系统**：FR-FCFS广泛应用于各种计算系统中，从个人电脑到大型服务器，特别是在需要高内存性能的应用中。

### 限制

-  **饿死现象（Starvation）**：FR-FCFS可能导致某些内存请求长时间等待，特别是在高负载下。如果行缓存命中的请求不断到达，那些需要新行激活的请求可能会被无限期地延迟，从而产生饿死现象。
总之，FR-FCFS算法通过优化内存请求的调度顺序，减少了因行切换导致的延迟，从而提高了DRAM的性能。然而，根据具体的应用场景和内存访问模式，可能还需要考虑其他优化策略。