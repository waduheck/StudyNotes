## 基础知识
在硬件描述语言（HDL）如Verilog中，`assign` 语句用于创建一个连续赋值，它描述了一种硬件电路的行为，而不是像传统的编程语言中那样的顺序执行。`assign` 语句定义了一个始终有效的关系，这意味着当表达式右侧的值发生变化时，左侧的值会立即更新。

对于语句 `assign q = (state == S0);`，它表示输出 `q` 是当前状态 `state` 是否等于 `S0` 的直接映射。在硬件中，这相当于一个组合逻辑电路，当 `state` 变量的值改变时，`q` 的值会根据这个关系立即更新。

在六个时钟周期内，这条 `assign` 语句不是被“执行”了特定次数，而是一直在连续地检测 `state` 的值，并根据 `state` 是否等于 `S0` 来实时更新 `q` 的值。因此，每当 `state` 的值发生变化时（在您的FSM中，这通常发生在时钟的上升沿），`q` 的值都会根据这个 `assign` 语句立即更新。在六个时钟周期内，如果 `state` 每个时钟周期都发生变化，`q` 的值也会在每个时钟周期都根据 `state` 的当前值更新。
![[Pasted image 20231204165216.png]]




![[Pasted image 20231204165815.png]]

![[Pasted image 20231204172305.png]]
![[Pasted image 20231204172452.png]]

## 实现transparent，同步，异步电路
transparent
![[Pasted image 20231204191922.png]]
同步电路
![[Pasted image 20231204192038.png]]
异步电路
![[Pasted image 20231204191949.png]]

## always块的记忆性
在Verilog中，`always` 块的“记忆性”取决于它们是用于描述组合逻辑还是时序逻辑。这与是否使用寄存器（reg类型的变量）来存储数据有关。

### 时序逻辑：具有记忆性

时序逻辑涉及到数据在时间上的变化，通常与时钟信号相关联。在时序逻辑的 `always` 块中，数据被存储在寄存器中，因此具有记忆性。

**例子**：

```verilog
always @(posedge clk)
    reg_a <= data;
```

- 在这个例子中，每当时钟信号 `clk` 的上升沿发生时，变量 `data` 的当前值被存储到寄存器 `reg_a` 中。
- 由于使用了寄存器 `reg_a`，这个 `always` 块具有记忆性，能够保持 `data` 的值直到下一个时钟上升沿。

### 组合逻辑：没有记忆性
![[Pasted image 20231204193917.png]]
组合逻辑仅依赖于当前的输入值，与过去的状态无关。在组合逻辑的 `always` 块中，不使用用于存储的寄存器，因此没有记忆性。

**例子**：
![[Pasted image 20231204194139.png]]
```verilog
always @(*)
    sum = a + b;
```

- 在这个例子中，`sum` 的值是输入 `a` 和 `b` 的即时和。
- 由于没有使用寄存器来存储 `sum` 的值，这个 `always` 块没有记忆性。`sum` 的值仅在 `a` 或 `b` 改变时改变。

### 总结

- **具有记忆性**：时序逻辑 `always` 块使用寄存器来存储数据，因此具有记忆性。这允许在不同的时钟周期间保持数据状态。
- **没有记忆性**：组合逻辑 `always` 块不使用寄存器，仅根据当前输入计算输出，因此没有记忆性。

理解这两种逻辑在硬件设计中的应用对于编写有效的Verilog代码至关重要。

## 阻塞赋值与非阻塞赋值
非阻塞赋值是在block的结尾并行执行的，并没有语句之间的顺序
![[Pasted image 20231204194514.png]]
赋值造成的信号变化也会导致always再次运行
![[Pasted image 20231204194727.png]]
## 设计规范
![[Pasted image 20231204194903.png]]
![[Pasted image 20231204194924.png]]

## FSM实例
![[Pasted image 20231204195800.png]]
