## 基础知识
![[Pasted image 20231204165216.png]]




![[Pasted image 20231204165815.png]]

![[Pasted image 20231204172305.png]]
![[Pasted image 20231204172452.png]]

## 实现transparent，同步，异步电路
transparent
![[Pasted image 20231204191922.png]]
同步电路
![[Pasted image 20231204192038.png]]
异步电路
![[Pasted image 20231204191949.png]]

## always块的记忆性
在Verilog中，`always` 块的“记忆性”取决于它们是用于描述组合逻辑还是时序逻辑。这与是否使用寄存器（reg类型的变量）来存储数据有关。

### 时序逻辑：具有记忆性

时序逻辑涉及到数据在时间上的变化，通常与时钟信号相关联。在时序逻辑的 `always` 块中，数据被存储在寄存器中，因此具有记忆性。

**例子**：

```verilog
always @(posedge clk)
    reg_a <= data;
```

- 在这个例子中，每当时钟信号 `clk` 的上升沿发生时，变量 `data` 的当前值被存储到寄存器 `reg_a` 中。
- 由于使用了寄存器 `reg_a`，这个 `always` 块具有记忆性，能够保持 `data` 的值直到下一个时钟上升沿。

### 组合逻辑：没有记忆性
![[Pasted image 20231204193917.png]]
组合逻辑仅依赖于当前的输入值，与过去的状态无关。在组合逻辑的 `always` 块中，不使用用于存储的寄存器，因此没有记忆性。

**例子**：
![[Pasted image 20231204194139.png]]
```verilog
always @(*)
    sum = a + b;
```

- 在这个例子中，`sum` 的值是输入 `a` 和 `b` 的即时和。
- 由于没有使用寄存器来存储 `sum` 的值，这个 `always` 块没有记忆性。`sum` 的值仅在 `a` 或 `b` 改变时改变。

### 总结

- **具有记忆性**：时序逻辑 `always` 块使用寄存器来存储数据，因此具有记忆性。这允许在不同的时钟周期间保持数据状态。
- **没有记忆性**：组合逻辑 `always` 块不使用寄存器，仅根据当前输入计算输出，因此没有记忆性。

理解这两种逻辑在硬件设计中的应用对于编写有效的Verilog代码至关重要。

## 阻塞赋值与非阻塞赋值
非阻塞赋值是在block的结尾并行执行的，并没有语句之间的顺序
![[Pasted image 20231204194514.png]]
赋值造成的信号变化也会导致always再次运行
![[Pasted image 20231204194727.png]]
## 设计规范
![[Pasted image 20231204194903.png]]
![[Pasted image 20231204194924.png]]