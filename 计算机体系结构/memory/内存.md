![[Pasted image 20231224100340.png]]
## 现存问题
读取耗时长
能耗高
密集DRAM会导致安全问题
## 寻址
好的，我会用通俗的语言来解释什么是字寻址（Word Addressable）和字节寻址（Byte Addressable），并举例说明。

### 字节寻址（Byte Addressable）

想象一下，内存就像是一排排的小盒子，每个盒子都有一个编号（这就是我们说的“地址”）。在字节寻址的系统中，每个盒子里只能放一个字节的数据（一个字节等于8位，可以是一个字符，比如'a'，或者是0到255之间的一个数字）。

#### 例子：
假设我们有一串字符 "hello"，在字节寻址的系统中，我们可以这样存储它们：

- 'h' 存在地址0的盒子里，
- 'e' 存在地址1的盒子里，
- 'l' 存在地址2的盒子里，
- 另一个 'l' 存在地址3的盒子里，
- 'o' 存在地址4的盒子里。

每个字符占据一个单独的地址。

### 字寻址（Word Addressable）

现在，假设每个盒子变大了，可以放更多的数据。在字寻址的系统中，每个盒子可以放一个“字”的数据。这里的“字”是一个固定的大小，比如16位、32位或者64位。所以，如果一个“字”是32位，那么每个盒子就可以存储4个字节（因为32位等于4个字节）。

#### 例子：
我们再拿 "hello" 这个例子。假设每个“字”是32位，那么在字寻址的系统中，我们可能这样存储：

- 'h', 'e', 'l', 'l' 这四个字符一起存储在地址0的盒子里（因为它们加起来是32位），
- 'o' 存储在地址1的盒子里（注意这里盒子里还有空间，但是因为是按“字”寻址，所以地址1的盒子是从这里开始的）。

在这种情况下，每个地址可以存储更多的信息，但是你不能只取出或只改变一个盒子里的一小部分，你需要一次处理整个“字”。


### 基址加偏移量
base + offset比如数组中
offset的计算方法
![[Pasted image 20231207202510.png]]
### 总结

- **字节寻址**：就像一排排只能放一个字节的小盒子，每个盒子有自己的编号，你可以单独访问每个盒子里的内容。
- **字寻址**：想象一排排可以放一个“字”（多个字节）的大盒子，每个盒子也有自己的编号，但你一次要处理一个盒子里的所有内容。

字节寻址提供了更高的灵活性，因为你可以精确地访问和修改内存中的每一个字节。字寻址在处理大量数据时可能更高效，但它牺牲了一些灵活性，因为你需要一次处理一个“字”的数据。

## 对齐

## 内存访问

MAR（Memory Address Register）和 MDR（Memory Data Register）是计算机架构中的两个关键组件，尤其是在处理内存操作时。

### MAR（Memory Address Register）

- **定义**：MAR是一个用于存储即将从内存读取或写入内存的数据的地址的寄存器。
- **功能**：当CPU需要访问内存时，它首先将数据的地址加载到MAR中。然后，这个地址被用来从内存系统中定位和访问实际的数据。
- **作用**：MAR起着桥梁的作用，将CPU和内存单元连接起来。它确保CPU可以准确地访问内存中的特定位置。

### MDR（Memory Data Register）

- **定义**：MDR是一个用于暂时存储从内存读取或写入内存的数据的寄存器。
- **功能**：当从内存读取数据时，数据首先被加载到MDR中，然后CPU可以从MDR获取这些数据。同样地，当向内存写入数据时，数据首先被放置在MDR中，然后从MDR传输到内存中的相应位置。
- **作用**：MDR作为CPU和内存之间数据传输的缓冲区，确保数据传输的顺畅和准确。

### 两者的相互关系

MAR和MDR在内存访问过程中密切协作。首先，CPU确定需要访问的内存位置并将该地址放入MAR中。接着，根据是读操作还是写操作，数据会从MDR传输到内存（写操作），或者从内存传输到MDR（读操作）。这个过程确保了CPU可以有效地与内存交换数据。

在实际的计算机操作中，这些寄存器对于高效和准确地处理内存操作至关重要。虽然它们在物理上可能是处理器的一部分，但在功能上，它们起着连接CPU和内存的关键作用。
### 读
![[Pasted image 20231207185028.png]]
1. **设置地址**：CPU首先确定要读取的内存地址，并将这个地址放入MAR（Memory Address Register）中。
    
2. **发出读取指令**：CPU向内存发出读取指令，通知内存控制器使用MAR中的地址来定位数据。
    
3. **数据传输**：内存控制器根据MAR中的地址找到相应的数据，并将其传输到MDR（Memory Data Register）中。
    
4. **CPU访问数据**：一旦数据被加载到MDR中，CPU就可以从MDR获取这些数据进行处理。
### 写
![[Pasted image 20231207185116.png]]
1. **设置地址**：CPU确定要写入数据的目标内存地址，并将这个地址放入MAR中。
    
2. **准备数据**：CPU将要写入的数据放入MDR中。
    
3. **发出写入指令**：CPU向内存发出写入指令，通知内存控制器使用MAR中的地址来定位目标内存位置。
    
4. **数据传输**：内存控制器从MDR中取出数据，并将其写入到由MAR指定的内存地址中。
### 总结

- 在**读操作**中，MAR用于指定要读取的内存地址，MDR用于存储从该地址读取的数据。
- 在**写操作**中，MAR用于指定要写入的内存地址，MDR用于存储要写入该地址的数据。
## 大端小端模式

大端模式（Big-Endian）和小端模式（Little-Endian）是指计算机存储多字节数据（如整数、浮点数）时，字节序（即字节的排列顺序）的两种不同方式。这是计算机架构中的一个基本概念，对于数据的解释和处理有重要影响。

### 大端模式（Big-Endian）

在大端模式中，多字节数据的最高有效字节（MSB，即那个数值最大的字节）存储在最低的内存地址上，而最低有效字节（LSB，即那个数值最小的字节）存储在最高的内存地址上。可以将其类比为人类阅读数字的方式，即最重要的数字（最高位）放在前面。

#### 举例：

假设有一个16位的数 `0x1234`（在十六进制表示中），在大端模式下，它在内存中的存储方式如下：

```
内存地址    数据
0x00        0x12
0x01        0x34
```

### 小端模式（Little-Endian）

在小端模式中，多字节数据的最低有效字节（LSB）存储在最低的内存地址上，而最高有效字节（MSB）存储在最高的内存地址上。这可以视作一种“倒序”存储，其中最小的部分在前面。

#### 举例：

对于同一个数 `0x1234`，在小端模式下，它在内存中的存储方式如下：

```
内存地址    数据
0x00        0x34
0x01        0x12
```

### 重要性和应用

- **网络通信**：在网络协议中通常使用大端模式，因为它更符合人类阅读和理解数字的习惯。
- **不同平台的兼容性**：不同的计算机架构可能采用不同的字节序。例如，Intel x86架构是小端模式，而许多RISC架构（如IBM的PowerPC）是大端模式。
- **数据交换**：在不同字节序的系统间交换数据时，需要进行字节序转换，以保证数据的正确解释。

了解和处理字节序问题在跨平台软件开发、网络通信等领域非常重要，尤其是在处理二进制数据时。


## RAM

### DRAM

### SRAM


## Bank
![[Pasted image 20231222144235.png]]

![[Pasted image 20231222144446.png]]

## DRAM控制器的调度算法——FR-FCFS
FR-FCFS（First-Ready First-Come First-Serve）是一种常用于DRAM控制器的调度算法，用于优化内存访问并减少由于缓存冲突导致的延迟。当发生访问不同行但同一bank的情况时，如您所描述的先访问第一行第一列，然后访问第二行第一列，会产生额外的延迟，因为每次访问不同行时，DRAM都需要进行预充电（precharge）和激活（activate）操作。FR-FCFS算法通过优化内存请求的处理顺序来解决这一问题。

### FR-FCFS算法的工作原理

#### 优先级调度
- **首先处理就绪请求**：FR-FCFS首先处理已经就绪的内存请求，即那些不需要额外行激活的请求。这通常意味着对当前已经在行缓存中的数据进行读写操作。
- **次之处理先到达的请求**：一旦所有就绪请求都被处理，算法再按照先到先服务的原则处理其他请求。

#### 减少行切换
- 通过优先处理那些可以直接服务的请求（即行缓存命中），FR-FCFS减少了行之间切换的次数，从而降低了因为行切换导致的延迟。

### 实现步骤

1. **请求分类**：将内存请求分为两类——行缓存命中（就绪）和行缓存未命中（非就绪）。
2. **优先处理行缓存命中**：检查行缓存命中的请求并优先处理。
3. **按先来先服务处理其他请求**：处理完所有行缓存命中的请求后，按照到达顺序处理剩余请求。

### 效果

- **降低延迟**：FR-FCFS通过减少行激活和预充电操作的次数，降低了内存访问的平均延迟。
- **提高吞吐量**：更高效的内存请求处理提高了DRAM的整体吞吐量。

### 应用

- **适用于多种系统**：FR-FCFS广泛应用于各种计算系统中，从个人电脑到大型服务器，特别是在需要高内存性能的应用中。

### 限制

-  **饿死现象（Starvation）**：FR-FCFS可能导致某些内存请求长时间等待，特别是在高负载下。如果行缓存命中的请求不断到达，那些需要新行激活的请求可能会被无限期地延迟，从而产生饿死现象。
总之，FR-FCFS算法通过优化内存请求的调度顺序，减少了因行切换导致的延迟，从而提高了DRAM的性能。然而，根据具体的应用场景和内存访问模式，可能还需要考虑其他优化策略。