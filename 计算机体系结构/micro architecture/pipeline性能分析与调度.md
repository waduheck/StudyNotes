![[Pasted image 20231213112414.png]]

### 软件基础的指令调度（静态调度）
在静态调度中，编译器在编译时决定指令的顺序，并且这个顺序在执行时保持不变。编译器会尝试排列指令，以避免数据冒险和结构冒险，并提高指令缓存的效率。这种方法的一个限制是编译器可能不知道每条指令的精确延迟，因为这些延迟可能取决于执行时的多种因素，如缓存未命中或分支预测错误。

### 动态调度
与静态调度相反，动态调度由处理器硬件在运行时执行。在动态调度中，处理器可以根据指令的就绪状态和资源的可用性重新排列指令的执行顺序，这使得处理器能够更有效地处理数据冒险和分支预测错误。动态调度通常需要更复杂的硬件支持，如乱序执行引擎。

### 编译器如何知道指令延迟
编译器通常知道指令的平均延迟，但它无法预测具体的运行时事件，如确切的缓存未命中延迟或执行特定操作的确切时间。

### 静态调度的困难
编译器在静态调度时面临的挑战包括无法预测的因素，如：

- **可变长度的操作延迟**：不同操作的执行时间可能因为多种因素而变化。
- **内存地址**：访问内存时可能发生的缓存命中或未命中。
- **分支方向**：编译器可能无法准确预测分支指令的结果。

### 编译器如何减轻这些问题
编译器可能会使用启发式方法来估计这些未知因素，或者使用优化算法来尽可能地减少它们对性能的影响。此外，编译器可以插入额外的指令来尝试隐藏潜在的延迟，或者重新排列指令顺序以利用流水线的并行性。这些技术旨在让生成的代码即使在存在未知因素的情况下也能有效地执行。