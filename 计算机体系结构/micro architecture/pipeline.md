![[Pasted image 20231212145031.png]]
![[Pasted image 20231212152038.png]]

## issues

### 资源争用（Resource Contention）
这段话描述的是如何在流水线微处理器中处理资源争用（Resource Contention）。资源争用发生在两个或多个流水线阶段同时需要同一资源时。

这里提出了两种解决资源争用的基本方法：

#### 解决方案1：消除争用的原因
- **复制资源或增加其吞吐量**：这可以通过增加资源的副本来实现，比如使用独立的指令和数据内存（比如分别的缓存）。另一个例子是使用具有多个端口的内存结构，这样可以同时支持多个读写操作。

#### 解决方案2：检测资源争用并暂停（stall）其中一个阶段
- **决定哪个阶段需要暂停**：当检测到资源争用时，需要决定哪个阶段的操作应该等待，这通常取决于流水线的设计和争用的具体情况。
- **举例**：如果有一个单一的读写端口寄存器文件，可能需要在写操作和读操作冲突时，选择暂停读操作或写操作。

#### 讲一个时钟周期划分为前半周期与后半周期
寄存器文件可以在同一个周期内进行读和写操作，避免了资源争用：

- 写操作发生在时钟周期的第一半部分。
- 读操作发生在时钟周期的第二半部分。
![[Pasted image 20231212160312.png]]

这段话的背景是流水线处理器的设计，其中资源争用和冒险是必须解决的问题。在设计和实现流水线控制逻辑时，必须考虑如何优雅地处理这些问题，以避免性能下降。解决方案可能包括硬件更改（如添加资源），也可能包括控制逻辑更改（如在检测到争用时引入暂停）。

### 依赖性问题
![[Pasted image 20231212161006.png]]
这张幻灯片展示了在处理器设计中处理数据依赖性时遇到的三种类型：

1. **流依赖（Flow Dependence）/ 读后写（Read-after-Write, RAW）**：
   这是最常见的数据依赖类型，发生在第一条指令写入一个寄存器，而紧接着的第二条指令需要读取同一个寄存器的情况。例如，如果 `r3` 是第一条指令的结果，而第二条指令需要使用 `r3`，那么第二条指令就必须等待第一条指令完成写入操作后才能执行。这种依赖性要求严格的执行顺序。

2. **反依赖（Anti Dependence）/ 写后读（Write-after-Read, WAR）**：
   反依赖发生在一条指令读取一个寄存器的情况，而紧接着的另一条指令准备写入同一个寄存器。在这种情况下，写操作必须等待读操作完成。例如，如果第一条指令从 `r1` 读取数据，而第二条指令准备将结果写入 `r1`，第二条指令的写入必须等到第一条指令完成读取。

3. **输出依赖（Output Dependence）/ 写后写（Write-after-Write, WAW）**：
   输出依赖发生在两条指令都尝试写入同一个寄存器的情况。后一条指令的写入操作必须等到前一条指令的写入操作完成，以确保寄存器中存储的是正确的值。例如，如果两条连续的指令都写入 `r3`，那么它们的执行顺序将决定 `r3` 的最终值。

在流水线处理器设计中，这些依赖性必须被正确管理，以避免错误的数据读取或写入。通常使用数据前递、流水线暂停和寄存器重命名等技术来解决这些问题。这些技术可以确保尽管指令并行执行，数据的完整性和正确的执行顺序仍然得到维护。

在流水线处理器设计中，数据依赖性可能导致冒险，这会阻碍流水线的顺畅执行。为了处理这些冒险，有几种常见的技术：

### 依赖性问题检测方法
是的，在处理器的指令流水线设计中，除了组合依赖性检查逻辑外，还有其他几种依赖性检测方法：

1. **得分板（Scoreboarding）**：这是一种动态调度方法，它跟踪每个功能单元的状态，哪个寄存器正在被读写，以及哪些功能单元正在等待某些寄存器。得分板可以用来暂停指令的发射，直到所有的数据依赖都已经解决。



2. **组合依赖性检查逻辑**：这是一种特殊的逻辑，用于检查在处理器的流水线中，是否有任何后续阶段的指令要写入当前正在解码的指令所需要的任何源寄存器。换言之，它检查是否存在数据依赖性，特别是流依赖性，这种依赖性发生在一个指令需要使用另一个指令的结果时。

	- **如何处理检查结果**：
	  - 如果检查结果为“是”（Yes），意味着存在依赖性，系统需要暂停（stall）指令或流水线，以等待必要的数据变得可用，避免错误的执行。
	  - 如果检查结果为“否”（No），意味着没有流依赖性，那么就没有必要暂停，指令可以继续执行。
	
	- **优点**（Advantage）：使用组合依赖性检查逻辑的优点是，没有必要在反向依赖性（anti-dependencies）和输出依赖性（output dependencies）上进行暂停。反向依赖性指的是后面的指令写入一个早期指令将要读取的寄存器，而输出依赖性指的是两个指令写入同一个寄存器的情况。
	
	- **缺点**（Disadvantage）：这种逻辑比得分板（scoreboard）——一种用于处理指令间依赖性的经典技术——更复杂。随着流水线变得更深、更宽（例如在超标量执行中），这种逻辑变得更加复杂。"Flash-forward"这个术语可能是指预测性执行的一种形式，即尝试提前执行指令以填充流水线，但是它需要更复杂的逻辑来管理潜在的依赖性和执行路径。

### 依赖性问题解决方法
#### 数据前递（Data Forwarding/Data Bypassing）

数据前递是解决RAW冒险的一种常用方法。当一条指令需要使用前一条指令的结果时，而该结果尚未写回寄存器，数据前递机制会将结果直接从产生它的流水线阶段转发到需要它的流水线阶段。

例如，如果指令A计算出结果并在执行阶段（EX）结束时产生了该结果，而指令B需要这个结果作为其执行阶段的输入，数据前递机制将从指令A的执行阶段直接将数据送到指令B的执行阶段，而不是等待结果被写回寄存器文件。

#### 流水线暂停（Pipeline Stalling/Pipeline Bubbles）

当数据前递不能解决依赖性问题时，如在WAR和WAW冒险情况下，或当数据前递硬件不可用时，流水线暂停被用作解决方案。这涉及到检测到冒险时暂停流水线的进一步操作，直到必需的数据可用。流水线暂停可以通过插入空操作（NOPs）或“气泡”来实现，这些空操作会在流水线中传递，但不执行任何操作。

#### 寄存器重命名（Register Renaming）

寄存器重命名是解决WAR和WAW冒险的技术。它涉及到使用额外的寄存器（物理寄存器）来消除对同一寄存器的多个操作之间的假冒险。通过为每个结果分配一个唯一的寄存器，可以确保写操作不会影响后续的读操作或其他写操作。这通常在硬件级别在分派阶段完成。

#### 分支预测（Branch Prediction）

分支预测是另一种技术，用于减少由于控制冒险（由分支指令引起）导致的流水线暂停。它猜测分支的结果，并按照这个猜测来继续执行。如果猜测是正确的，流水线继续无缝执行；如果猜测错误，已经执行的指令需要被取消，并从正确的位置重新开始执行。

#### 指令重排序（Instruction Reordering）

指令重排序是动态调整指令执行顺序的技术，通常在超标量或乱序执行处理器中使用。它通过指令调度单元根据数据依赖性和资源可用性来调整指令的执行顺序，从而最小化流水线暂停和提高执行效率。

#### 软件方法

编译器优化也可以用来减少冒险。编译器可以重新排列指令顺序或插入NOP指令来避免冒险。这种方法在编译时静态解决问题，不需要硬件支持。

这些技术可以单独使用也可以组合使用，以优化流水线的性能，确保数据一致性，并最大限度地提高处理器资源的利用率。在现代处理器中，这些技术通常由复杂的硬件逻辑实现，并由高级指令调度算法辅助。