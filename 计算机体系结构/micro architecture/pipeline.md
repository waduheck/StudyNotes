![[Pasted image 20231212145031.png]]
![[Pasted image 20231212152038.png]]

## issues

### 资源争用（Resource Contention）
这段话描述的是如何在流水线微处理器中处理资源争用（Resource Contention）。资源争用发生在两个或多个流水线阶段同时需要同一资源时。

这里提出了两种解决资源争用的基本方法：

#### 解决方案1：消除争用的原因
- **复制资源或增加其吞吐量**：这可以通过增加资源的副本来实现，比如使用独立的指令和数据内存（比如分别的缓存）。另一个例子是使用具有多个端口的内存结构，这样可以同时支持多个读写操作。

#### 解决方案2：检测资源争用并暂停（stall）其中一个阶段
- **决定哪个阶段需要暂停**：当检测到资源争用时，需要决定哪个阶段的操作应该等待，这通常取决于流水线的设计和争用的具体情况。
- **举例**：如果有一个单一的读写端口寄存器文件，可能需要在写操作和读操作冲突时，选择暂停读操作或写操作。

#### 讲一个时钟周期划分为前半周期与后半周期
寄存器文件可以在同一个周期内进行读和写操作，避免了资源争用：

- 写操作发生在时钟周期的第一半部分。
- 读操作发生在时钟周期的第二半部分。
![[Pasted image 20231212160312.png]]

这段话的背景是流水线处理器的设计，其中资源争用和冒险是必须解决的问题。在设计和实现流水线控制逻辑时，必须考虑如何优雅地处理这些问题，以避免性能下降。解决方案可能包括硬件更改（如添加资源），也可能包括控制逻辑更改（如在检测到争用时引入暂停）。

### 依赖性问题
![[Pasted image 20231212161006.png]]
这张幻灯片展示了在处理器设计中处理数据依赖性时遇到的三种类型：

1. **流依赖（Flow Dependence）/ 读后写（Read-after-Write, RAW）**：
   这是最常见的数据依赖类型，发生在第一条指令写入一个寄存器，而紧接着的第二条指令需要读取同一个寄存器的情况。例如，如果 `r3` 是第一条指令的结果，而第二条指令需要使用 `r3`，那么第二条指令就必须等待第一条指令完成写入操作后才能执行。这种依赖性要求严格的执行顺序。

2. **反依赖（Anti Dependence）/ 写后读（Write-after-Read, WAR）**：
   反依赖发生在一条指令读取一个寄存器的情况，而紧接着的另一条指令准备写入同一个寄存器。在这种情况下，写操作必须等待读操作完成。例如，如果第一条指令从 `r1` 读取数据，而第二条指令准备将结果写入 `r1`，第二条指令的写入必须等到第一条指令完成读取。

3. **输出依赖（Output Dependence）/ 写后写（Write-after-Write, WAW）**：
   输出依赖发生在两条指令都尝试写入同一个寄存器的情况。后一条指令的写入操作必须等到前一条指令的写入操作完成，以确保寄存器中存储的是正确的值。例如，如果两条连续的指令都写入 `r3`，那么它们的执行顺序将决定 `r3` 的最终值。

在流水线处理器设计中，这些依赖性必须被正确管理，以避免错误的数据读取或写入。通常使用数据前递、流水线暂停和寄存器重命名等技术来解决这些问题。这些技术可以确保尽管指令并行执行，数据的完整性和正确的执行顺序仍然得到维护。