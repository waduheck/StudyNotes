
## 搜索

### 深度优先

### 广度优先
## 最小生成树

普里姆（Prim）算法和克鲁斯卡尔（Kruskal）算法都是用于在加权无向图中找到最小生成树（MST）的贪心算法。最小生成树是原图的一个子图，它连接了图中的所有顶点，具有最小可能的边的权重总和，并且不形成任何环。

### Prim算法的思想：

普里姆算法的核心思想是从图中的一个顶点开始，逐步增长最小生成树，每一步都添加一条连接树与非树顶点的最小边。

1. 初始化：选择一个起点，将其加入最小生成树中（可以将该点视为最小生成树的一个单点集合）。
2. 重复以下步骤，直到最小生成树包含所有顶点：
   - 查找所有连接最小生成树和图中其他顶点（非树顶点）的边。
   - 从这些边中选择权重最小的边。
   - 将这条边以及它所连接的非树顶点加入到最小生成树中。

普里姆算法适合用于边的数量较多的稠密图，因为它每次都是查找最小边。

### Kruskal算法的思想：

克鲁斯卡尔算法的核心思想是按照边的权重顺序处理所有边，并且每次都添加一条没有形成环的最小边到最小生成树中。

1. 创建一个森林，其中每个顶点都是一个独立的树。
2. 将所有边按权重从小到大排序。
3. 遍历排序后的边列表，重复以下步骤，直到森林变成单个树，即最小生成树：
   - 如果添加当前的最小边不会在森林中形成环，那么将它添加到森林中（这会合并两个树）。
   - 如果添加当前的最小边会形成环，则跳过这条边。

克鲁斯卡尔算法特别适合用于边的数量相对较少的稀疏图。

在两者中，选择哪一个算法通常取决于图的稠密程度以及可用的数据结构。Prim算法通常使用优先队列来快速选择最小边，而Kruskal算法需要能够快速判断边的添加是否会形成环，通常使用并查集（Union-Find）数据结构来实现。

## 最短路径
**Dijkstra算法，Floyd算法，Bellman-Ford算法和SPFA算法**

## 拓扑排序